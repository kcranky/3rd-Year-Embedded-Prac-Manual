\section{Toolchains Compilation and MakeFiles}

\subsection{Toolchains}

\subsection{Compilation}

\subsection{Make Files}
\href{https://www.gnu.org/software/make/manual/make.html}{https://www.gnu.org/software/make/manual/make.html}

\begin{verbatim}
cc = g++
ccflags = -lm
obj = adder.o
adder: $(obj)
    $(cc) $(ccflags) -o adder $(obj)
clean: 
    rm $(obj)
\end{verbatim}

\subsection{Cross Compilation}
When it comes to large programs, it is useful to use a more powerful system to compile the program for the Raspberry Pi as opposed to the Raspberry Pi itself. This can save you time and effort.

\subsubsection{Requirements}
On Windows, download and install the cross compilation framework: \newline
\href{http://gnutoolchains.com/raspberry/}{ http://gnutoolchains.com/raspberry/} \newline
When installing, make sure you select "Add to Path".

On a Linux/Ubuntu-based system, run
\begin{verbatim}
    $ sudo apt-get install libc6-armel-cross libc6-dev-armel-cross 
    $ sudo apt-get install binutils-arm-linux-gnueabi libncurses5-dev
    $ sudo apt-get install gcc-arm-linux-gnueabi
\end{verbatim}

\subsubsection{Using cross compilation}
Cross compilation is as simple as setting a different compiler in your make file or compilation script.
For example, instead of 
\begin{verbatim}
    $ g++ -ggdb <file>.c -o <compiled_file_name>
\end{verbatim}
You would run
\begin{verbatim}
    $ arm-linux-gnueabihf-g++ -ggdb <file>.c -o <compiled_file_name>
\end{verbatim}

\subsubsection{Moving the files to the Pi}
To move the compiled files to the Pi, SCP (See section \ref{sec:SCP}) is quick and painless solution. 
Once the compiled file has been copied across, add the execution flag and run the file by running the following commands on the Raspberry Pi:
\begin{verbatim}
    $ chmod +x <compiled_file_name>
    $ ./<compiled_file_name>
\end{verbatim}
