\section{Toolchains Compilation and MakeFiles}
\subsection{Toolchains}
A toolchain is a collection of tools that enables you to write code for an embedded system. For C-based development, a toolchain may consist of the following:
\begin{itemize}
    \item A text editor or IDE\\
    This is used to write the code that you plan to run on your embedded system.
    \item Make\\
    An automation tool for compiling, linking, and executing files. More on this later.
    \item Compiler\\
    Turns the C code you've written into assembly
    \item Assembler\\
    Turns assembly code into binary object files
    \item Linker\\
    A linker takes one or more object files and converts them into an executable which can run on the target system.
\end{itemize}

Usually the compiler, assembler and linker are all integrated into one single command which can be run. The most common of these is GCC (GNU Compiler Compiler Collection) which is what will be used in this course.

\subsection{Compilation}
To compile a C or C\# file to run on the RPi, simply run:
\begin{verbatim}
\$ arm-linux-gnueabihf-g++ <file>.c -o <compiled_file_name>
\end{verbatim}
If you are on the Raspberry Pi, you can just run the following:
\begin{verbatim}
\$ g++ <file>.c -o <compiled_file_name>
\end{verbatim}
\subsection{Make Files}
\href{https://www.gnu.org/software/make/manual/make.html}{https://www.gnu.org/software/make/manual/make.html}
\textbf{TODO: Further explain make files}
\begin{verbatim}
cc = g++
ccflags = -lm
obj = adder.o
adder: $(obj)
    $(cc) $(ccflags) -o <output_file_name> $(obj)
clean: 
    rm $(obj)
\end{verbatim}

\subsection{Useful Compiler flags}
-ggdb for debugging

\textbf{TODO: Should include CPU directives here? Depends on Prac 2}


\subsection{Cross Compilation}
When it comes to large programs, or programs that you may need to test with multiple parameters, it is useful to use a more powerful system to compile the program for the Raspberry Pi as opposed to the Raspberry Pi itself. This can save you time and effort.

\subsubsection{Requirements}
On Windows, download and install the cross compilation framework: \newline
\href{http://gnutoolchains.com/raspberry/}{ http://gnutoolchains.com/raspberry/} \newline
When installing, make sure you select "Add to Path".

On a Linux/Ubuntu-based system, run
\begin{verbatim}
    $ sudo apt-get install libc6-armel-cross libc6-dev-armel-cross 
    $ sudo apt-get install binutils-arm-linux-gnueabi libncurses5-dev
    $ sudo apt-get install gcc-arm-linux-gnueabi
\end{verbatim}

\subsubsection{Using cross compilation}
Cross compilation is as simple as setting a different compiler in your make file or compilation script.
For example, instead of 
\begin{verbatim}
    $ g++  <file>.c -o <compiled_file_name>
\end{verbatim}
You would run
\begin{verbatim}
    $ arm-linux-gnueabihf-g++ <file>.c -o <compiled_file_name>
\end{verbatim}

\subsubsection{Moving the files to the Pi}
To move the compiled files to the Pi, SCP (See section \ref{sec:SCP}) is quick and painless solution. 
Once the compiled file has been copied across, add the execution flag and run the file by running the following commands on the Raspberry Pi:
\begin{verbatim}
    $ chmod +x <compiled_file_name>
    $ ./<compiled_file_name>
\end{verbatim}
